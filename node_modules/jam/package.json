{
  "name": "jam",
  "version": "0.4.3-0",
  "description": "JAM your async calls together *faster*",
  "main": "index.js",
  "scripts": {
    "test": "make test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/chakrit/jam.git"
  },
  "keywords": [
    "jam",
    "async",
    "monad",
    "concurrent",
    "parallel"
  ],
  "author": {
    "name": "Chakrit Wichian",
    "email": "service@chakrit.net",
    "url": "http://chakrit.net"
  },
  "license": "BSD",
  "readmeFilename": "README.md",
  "directories": {
    "test": "test",
    "lib": "lib"
  },
  "devDependencies": {
    "istanbul": "~0.1.27",
    "mocha-istanbul": "~0.1.0",
    "mocha": "~1.8.1",
    "plato": "~0.4.3",
    "chai": "~1.4.2",
    "sinon": "~1.5.2",
    "groc": "~0.3.2"
  },
  "readme": "[![Build Status](https://travis-ci.org/chakrit/jam.png?branch=master)](https://travis-ci.org/chakrit/jam)\n\n# JAM JAM JAM\n\n```sh\n$ npm install jam --save\n```\n\nJAM is another kind of async framework that tries to have as minimum boilerplate code as\npossible with sensible defaults. (Or as sensible as I can make it; PR and ideas welcome.)\n\nJAM wants you to get right in to building your `async` chain as soon as possible.\n\nJAM also aims to bundle with itself some \"combinators\" (or just \"helpers\") which helps you\nmanipulate arguments and functions that are being passed around in the chain with ease.\nThere is only a handful of them right now, but I will add more whenever I see a good use\nfor one.\n\n# HOW TO\n\nJAM functions must accept a `next` argument first thing which you should call as soon as\nyour asynchronous processing is done:\n\nLet's start with the simplest possible invocation of jam:\n\n```js\nvar chain = jam( function(next) { next(); } );\n```\n\n**JAM will starts executing your chain as soon as `nextTick`.** So, in the event loop time\nyou have been allocated, you can add as many methods as you like and the chain will start\nexecuting as soon your loop finishes. No more steps necessary!\n\nYou may think that this poses a problem but I find that most (if not all) of the cases\nwhere you want to do multiple asynchronous calls, you will build all your calls in a\nsingle run loop. So this is a non-issue.\n\nTo add a method to the chain, simply invoke the result from the last JAM invocation as a\nfunction like this:\n\n```js\nchain = chain( function secondStep(next) { next(); } );\n```\n\nJAM expects most asynchronous method calls to be executed serially so that is what the\nchain does by default when you start adding methods to the chain.\n\nSince JAM return values are just functions, you don't even need to hold it in a variable\nif you like extra brevity of code:\n\n```js\njam( function firstStep(next)  { next(); } )\n  (  function secondStep(next) { next(); } )\n  (  function lastStep()       { } );\n```\n\nJAM also handles `Error`s for you. Note:\n\n* The convention here is that the last function in the chain is often the one that will\n  handle all errors in the chain.\n* The last function does not need any more `next()` since it's the last one.\n\nJAM convention utilizes the two facts above to pass any `Error` that happens in the chain\nto the last function as first argument.\n\nSo if you need error handling, write the last function as a standard node.js callback:\n\n```js\njam(function erroneous(next) {\n    next(new Error('naw!');\n  })\n  (function handler(err) {\n    if (err) { console.log(err.stack); }\n  });\n```\n\nAdditionally, JAM also passes anything else given to the `next()` function to the next one\nas arguments as well so you can do this:\n\n```js\njam(function(next) { fs.readFile('filename.txt', next); })\n  (function(next, data) {\n    console.log(\"FILE DATA:\\r\\n\" + data);\n  });\n```\n\nThis is much better than if JAM put `next()` as the last argument since some functions\ncalls your `callback` with more arguments than you need (or aware of) thus making your\ncode dependent on the number of arguments given.\n\nPassing `next` as first argument eliminates the dependency since you can bind as many\narguments as you want and the `next()` is still passed as first argument always.\n\nAdditionally, there are helpers available that lets you build JAM chains more easily.\n\n# HELPERS\n\nThis is just a quick list to give you some ideas. More documentation on helpers are\navailable with with the [annotated source of jam.js](http://gh.chakrit.net/jam/).\n\nOr feel free to ping me [@chakrit](http://twitter.com/chakrit) on Twitter or open a GH\nissue for questions.\n\n#### identity( )\n\n```js\njam(function first(next) { next('one'); })\n  (jam.identity)\n  (function second(err, arg) {\n    assert(arg === 'one'); // passese\n  });\n```\n\nPasses arguments it receives to the next function in the chain without any modification.\nAlso useful as a starting point when building a complex jam chain (i.e. in a for loops\nthat re-uses the jam return values.)\n\nSee `nextTick()` below.\n\n#### nextTick( )\n\n```js\njam( function firstStep(next) { next(); } )\n  ( jam.nextTick )\n  ( function badSecondStep(next) { next(); } );\n```\n\nExcept for the first invocation, JAM chains are executed synchronously one after another\nas soon as you call `next()`. This may pose a problem for some code that does not expect\nasynchronous functions to execute immeditaely.\n\nThis function fixes this case by inserting a nextTick() in-between the call chain to make\nsure it executes on `process.nextTick`.\n\nThis function is actually just an alias for `.identity`\n\n#### return( [args...] )\n\n```js\nfunction handleFileContent(e, file) {\n};\n\n// parallel handleFileContent jam\n['file1.txt', 'file2.txt', 'file3.txt'].forEach(function(file) {\n  jam(jam.return(file))\n    (jam.call(fs.readFile)) // no function() needed!\n    (handleFileContent);\n});\n```\n\nThis allows you to provide arguments to the next function in the chain (or for starting\nit) without modifying or wrapping code for the rest of the chains.\n\n#### call( func, [args...] )\n\n```js\njam(jam.call(findTheRightFile))\n  (jam.call(fs.readFile))\n  (function(e, fileContent) {\n    // fileContent is the content of the right file\n  });\n```\n\nThis helper lets you call standard node.js functions that expect callbacks at the end.\nAdditionally, any arguments that would normally be given to the chain function would be\nused to call the function instead (`next()` is then added at the end of the arguments\nlist).\n\n#### map( array, iterator( next, element, index ) )\n\n```js\nvar FILES = 'file1.txt,file2.txt,file3.txt'.split(',')\n  , cat = '';\n\njam(jam.map(FILES, function(next, file) {\n  fs.readFile(file, function(e, fileContent) {\n    cat += fileContent\n    next();\n  });\n\n})(function(e) { console.log(cat); });\n```\n\nRuns the `iterator` for each element in the array. The `iterator` is given its own version\nof `next()` and the element to process.\n\nInternally a new JAM chain is built and a chain step is added for each element.\n\n# LICENSE\n\nBSD\n\n# SUPPORT / CONTRIBUTE\n\nPull requests and/or ideas welcome.\n\nPlease open a [new GitHub Issue](https://github.com/chakrit/jam/issues/new) for any bugs\nyou find or if you just had a question.\n\n#### TODOs\n\n* Binded calls. Something like `jam.method(object, 'func')` that works like `jam.call`.\n* Nullify calls, in case you don't want any arguments passed.\n* Parellel map() ?\n\n# WHY ?\n\nShort answer: Because the existing ones are so cumbersome to use that I just had enough\nwith it.\n\nYeah, I know there're tons of other continuation helpers out there already but there\nreally isn't one where you could quickly just type-in the list of stuff to do and be done\nwith it without worrying about forgetting to close the list with that final parenthesis or\nforgetting to add a comma. And yeah, IMO it is wayyy easier to just add a\n`(function() { })` block at the end because that's what you're usually doing all the time\nanyway taking care of all those JS variable scopes. Plus it is easier to\ncopy/paste/reorder the steps as well.\n\nAnother thing is that most of the libraries try to provide you with a lot of powerful way\nto run asynchronous functions where most of the time you just want to reduce the amount of\nnesting in your code.\n\nSo my idea is that the interface should be really minimal using the most common case with\nsane defaults and then provide helpers for bringing edge cases into this minimal interface\nneatly so you can just get your stuff done without worrying about wether you are using the\nright async call or if you have the right number of arguments.\n\nSo I decided, WTH, I had enough and I could just write one.\n\nAnd you gotta admit, writing all these stuff is just god damned *fun*! XD\n\n",
  "_id": "jam@0.4.3-0",
  "_from": "jam@0.4.3-0"
}
